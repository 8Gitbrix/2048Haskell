
==================== FINAL INTERFACE ====================
2017-12-04 22:31:24.124656 UTC

interface main@main:Logic 8002
  interface hash: feafd7769ec9617ddabb73c49ffa46ec
  ABI hash: 649e0f6f397e7940c6a8eeadd4b2d33d
  export-list hash: f4197bae19c0657ba6cd777f66397ab8
  orphan hash: 5c6afa542ca157feb54eeb37258af508
  flag hash: db8b3dba68660d93bea9bec96c028028
  sig of: Nothing
  used TH splices: True
  where
exports:
  Logic.checkFull
  Logic.checkRowDecreasing
  Logic.checkRowFull
  Logic.checkRowIncreasing
  Logic.checkRowMonotonicity
  Logic.checkTileExists
  Logic.colorGrid
  Logic.colorRow
  Logic.countMergesInRow
  Logic.countNothingInRow
  Logic.directionStuckCheck
  Logic.directionStuckHeuristic
  Logic.done
  Logic.findBestMove
  Logic.findBestMove2
  Logic.grid
  Logic.initGame
  Logic.insertRandomTile
  Logic.insertRandomTileInRow
  Logic.largeEdgeNumberHeuristic
  Logic.leftGrid
  Logic.leftRow
  Logic.makeRandomTile
  Logic.mergeRow
  Logic.mergesHeuristic
  Logic.monotonicityHeuristic
  Logic.monteCarloPlayBoard
  Logic.oneBestMove
  Logic.oneMove
  Logic.openSquareHeuristic
  Logic.printTile
  Logic.randomlyPlayBoard
  Logic.randomlyPlayTilWin
  Logic.removeNothings
  Logic.runRandomN
  Logic.score
  Logic.scoreGrid
  Logic.scoreRow
  Logic.stuckCheck
  Logic.Direction{Logic.Down Logic.Left Logic.Right Logic.Up}
  Logic.Game{Logic.Game _done _grid _score}
  Logic.Grid
  Logic.Tile
module dependencies:
package dependencies: StateVar-1.1.0.4@StateVar-1.1.0.4-5dJbnTVECtEAhfJXPZKdbO
                      adjunctions-4.3@adjunctions-4.3-A5jfd1yrmaY4DRMJuiquBp
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu
                      bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw
                      binary-0.8.3.0@binary-0.8.3.0
                      bytes-0.15.3@bytes-0.15.3-JnJk9rvpCHsKPq5vbMmKHS
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      call-stack-0.1.0@call-stack-0.1.0-FYVrCPXGP9EGAuTW32963O
                      cereal-0.5.4.0@cereal-0.5.4.0-BsAGxfp8yAs3CiRo2E875e
                      comonad-5.0.2@comonad-5.0.2-Fq9Xy9jdx6uIyJZn00E6Yc
                      containers-0.5.7.1@containers-0.5.7.1
                      contravariant-1.4@contravariant-1.4-29zF0Im431177ovfbHYCGv
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      distributive-0.5.3@distributive-0.5.3-IX4kyVcHAyoH4uFYrsjY1R
                      exceptions-0.8.3@exceptions-0.8.3-ADEDRATtUrMK1JW4zMQ9U
                      free-4.12.4@free-4.12.4-C2gBQV0m8J42HxqSLTFyVx
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1
                      integer-logarithms-1.0.2@integer-logarithms-1.0.2-92lMiWV9mmYAwfMEYgfQ0D
                      kan-extensions-5.0.2@kan-extensions-5.0.2-8LTJJ1zQJWB7SfewWXUuqX
                      lens-4.15.4@lens-4.15.4-Km66e7WFRbEC7HnDdV2JDW
                      linear-1.20.7@linear-1.20.7-Hm7B9kQS5iJ4TZVBdSCC2p
                      microlens-0.4.8.1@microlens-0.4.8.1-BVhsezHoPw9Ez18LAXVtpM
                      microlens-th-0.4.1.1@microlens-th-0.4.1.1-DWxGvZm1QBXHYYQf0fHp0m
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      prelude-extras-0.4.0.3@prelude-extras-0.4.0.3-BhL9U5k7NtGJn1itwIHt2Y
                      pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      profunctors-5.2.1@profunctors-5.2.1-Ga89Nyw0d7LBEIoX4AZ6gT
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      reflection-2.1.2@reflection-2.1.2-Bem12O1xFGSHr4C2Hyu1c4
                      scientific-0.3.5.2@scientific-0.3.5.2-FM2NdrNTcdbCDq9wuNnhIA
                      semigroupoids-5.2.1@semigroupoids-5.2.1-Db8txM8kTsI6Y49CY6g5Jn
                      stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve
                      tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      th-abstraction-0.2.6.0@th-abstraction-0.2.6.0-HRFJgpoqs5HJ5LgHnjmMhQ
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      transformers-compat-0.5.1.4@transformers-compat-0.5.1.4-IuFogs8HAVUJBWVNMhtssu
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
                      vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu:Data.Orphans
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         linear-1.20.7@linear-1.20.7-Hm7B9kQS5iJ4TZVBdSCC2p:Linear.Instances
         reflection-2.1.2@reflection-2.1.2-Bem12O1xFGSHr4C2Hyu1c4:Data.Reflection
         stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve:Control.Monad.STM
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Fusion.Bundle
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
family instance modules: adjunctions-4.3@adjunctions-4.3-A5jfd1yrmaY4DRMJuiquBp:Data.Functor.Rep
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Biff
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Clown
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Fix
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Flip
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Join
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Joker
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Product
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Sum
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Tannen
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Wrapped
                         bytes-0.15.3@bytes-0.15.3-JnJk9rvpCHsKPq5vbMmKHS:Data.Bytes.Get
                         bytes-0.15.3@bytes-0.15.3-JnJk9rvpCHsKPq5vbMmKHS:Data.Bytes.Signed
                         bytes-0.15.3@bytes-0.15.3-JnJk9rvpCHsKPq5vbMmKHS:Data.Bytes.VarInt
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         kan-extensions-5.0.2@kan-extensions-5.0.2-8LTJJ1zQJWB7SfewWXUuqX:Data.Functor.Day
                         kan-extensions-5.0.2@kan-extensions-5.0.2-8LTJJ1zQJWB7SfewWXUuqX:Data.Functor.Yoneda
                         lens-4.15.4@lens-4.15.4-Km66e7WFRbEC7HnDdV2JDW:Control.Lens.At
                         lens-4.15.4@lens-4.15.4-Km66e7WFRbEC7HnDdV2JDW:Control.Lens.Internal.Indexed
                         lens-4.15.4@lens-4.15.4-Km66e7WFRbEC7HnDdV2JDW:Control.Lens.Reified
                         lens-4.15.4@lens-4.15.4-Km66e7WFRbEC7HnDdV2JDW:Control.Lens.Tuple
                         lens-4.15.4@lens-4.15.4-Km66e7WFRbEC7HnDdV2JDW:Control.Lens.Wrapped
                         lens-4.15.4@lens-4.15.4-Km66e7WFRbEC7HnDdV2JDW:Control.Lens.Zoom
                         linear-1.20.7@linear-1.20.7-Hm7B9kQS5iJ4TZVBdSCC2p:Linear.V
                         linear-1.20.7@linear-1.20.7-Hm7B9kQS5iJ4TZVBdSCC2p:Linear.V1
                         linear-1.20.7@linear-1.20.7-Hm7B9kQS5iJ4TZVBdSCC2p:Linear.V2
                         microlens-0.4.8.1@microlens-0.4.8.1-BVhsezHoPw9Ez18LAXVtpM:Lens.Micro.Internal
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Data.Primitive.Array
                         profunctors-5.2.1@profunctors-5.2.1-Ga89Nyw0d7LBEIoX4AZ6gT:Data.Profunctor.Rep
                         tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt:Data.Tagged
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         th-abstraction-0.2.6.0@th-abstraction-0.2.6.0-HRFJgpoqs5HJ5LgHnjmMhQ:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Primitive
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Storable
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed.Base
import  -/  base-4.9.1.0:Control.Applicative 32430a90492e727f4bd80db71c28600c
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Control.Monad.IO.Class 1a4384f66ee999caf5366398edb6ca7b
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.IO.Unsafe 1c057c642b0e201f55a24585d3d94564
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO c9de64c5f5407c4cf1c52500c4d15200
import  -/  base-4.9.1.0:System.IO.Unsafe 1e3c5b8dd8cf6850ae43cce967bb46cd
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Sequence c9764451c7ea31b534e87988fc642948
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  linear-1.20.7@linear-1.20.7-Hm7B9kQS5iJ4TZVBdSCC2p:Linear.V2 84a63a6b3f6e8f8486d121e776ecbcc6
import  -/  microlens-0.4.8.1@microlens-0.4.8.1-BVhsezHoPw9Ez18LAXVtpM:Lens.Micro 17ccad91e2fea7d0a9e5062fed73ea61
import  -/  microlens-0.4.8.1@microlens-0.4.8.1-BVhsezHoPw9Ez18LAXVtpM:Lens.Micro.Type fee04ed92cecdc88f8c4117ad9a626c5
import  -/  microlens-th-0.4.1.1@microlens-th-0.4.1.1-DWxGvZm1QBXHYYQf0fHp0m:Lens.Micro.TH 97d57810f7a9c6c0bfab58de69e959f2
import  -/  random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog:System.Random cc3ef358c669b194cf9fe94db6f2430f
8d4b988266ab87805c94d9bc03d5ebc3
  $fEqDirection :: GHC.Classes.Eq Logic.Direction
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Logic.Direction
                  Logic.$fEqDirection_$c==
                  Logic.$fEqDirection_$c/= -}
8d4b988266ab87805c94d9bc03d5ebc3
  $fEqDirection_$c/= ::
    Logic.Direction -> Logic.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Logic.Direction) (b :: Logic.Direction) ->
                 case a of wild {
                   Logic.Up
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Logic.Up -> GHC.Types.False }
                   Logic.Down
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Logic.Down -> GHC.Types.False }
                   Logic.Left
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Logic.Left -> GHC.Types.False }
                   Logic.Right
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Logic.Right -> GHC.Types.False } }) -}
8d4b988266ab87805c94d9bc03d5ebc3
  $fEqDirection_$c== ::
    Logic.Direction -> Logic.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Logic.Direction) (ds1 :: Logic.Direction) ->
                 case ds of wild {
                   Logic.Up
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Logic.Up -> GHC.Types.True }
                   Logic.Down
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Logic.Down -> GHC.Types.True }
                   Logic.Left
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Logic.Left -> GHC.Types.True }
                   Logic.Right
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Logic.Right -> GHC.Types.True } }) -}
f8fdb6d9549dc40d8ac3963099c4e7cc
  $fEqGame :: GHC.Classes.Eq Logic.Game
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Logic.Game Logic.$fEqGame_$c== Logic.$fEqGame_$c/= -}
bfd637cdd5c6a5d1cf101b16087e9397
  $fEqGame1 :: GHC.Classes.Eq Logic.Tile
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Logic.$fEqGame_$s$fEqMaybe -}
f8fdb6d9549dc40d8ac3963099c4e7cc
  $fEqGame_$c/= :: Logic.Game -> Logic.Game -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U)><S(SLL),1*U(1*U,1*U(U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Logic.Game) (b :: Logic.Game) ->
                 case Logic.$fEqGame_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f8fdb6d9549dc40d8ac3963099c4e7cc
  $fEqGame_$c== :: Logic.Game -> Logic.Game -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U)><S(SLL),1*U(1*U,1*U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Logic.Game) (w1 :: Logic.Game) ->
                 case w of ww { Logic.Game ww1 ww2 ww3 ->
                 case w1 of ww4 { Logic.Game ww5 ww6 ww7 ->
                 Logic.$w$c== ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
6cef739d76fabb977d4636ecdbe054ed
  $fEqGame_$s$fEqMaybe ::
    GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  Logic.$fEqGame_$s$fEqMaybe_$c==
                  (GHC.Base.$fEqMaybe_$c/= @ GHC.Types.Int GHC.Classes.$fEqInt) -}
80eb7f8ab763d32beeaea01e9648c780
  $fEqGame_$s$fEqMaybe_$c== ::
    GHC.Base.Maybe GHC.Types.Int
    -> GHC.Base.Maybe GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Int)
                   (ds1 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Classes.eqInt a1 b1 } }) -}
d337e540e0912987a271f8fbec23bd43
  $fEqGame_$s$fEq[] :: GHC.Classes.Eq [GHC.Base.Maybe GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [GHC.Base.Maybe GHC.Types.Int]
                  (GHC.Classes.$fEq[]_$c==
                     @ (GHC.Base.Maybe GHC.Types.Int)
                     Logic.$fEqGame1)
                  Logic.$fEqGame_$s$fEq[]_$c/= -}
05f1c7dbd20d3d943d89b2d2878aaa0f
  $fEqGame_$s$fEq[]_$c/= ::
    [GHC.Base.Maybe GHC.Types.Int]
    -> [GHC.Base.Maybe GHC.Types.Int] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: [GHC.Base.Maybe GHC.Types.Int])
                   (y :: [GHC.Base.Maybe GHC.Types.Int]) ->
                 GHC.Classes.not
                   (GHC.Classes.$fEq[]_$c==
                      @ (GHC.Base.Maybe GHC.Types.Int)
                      Logic.$fEqGame1
                      x
                      y)) -}
8d4b988266ab87805c94d9bc03d5ebc3
  $fShowDirection :: GHC.Show.Show Logic.Direction
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Logic.Direction
                  Logic.$fShowDirection_$cshowsPrec
                  Logic.$fShowDirection_$cshow
                  Logic.$fShowDirection_$cshowList -}
9c9522b113029b77fca06228fe8e9728
  $fShowDirection1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Right"#) -}
39dc75142121fe6bf9b22eb0c4bd6b1e
  $fShowDirection2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Left"#) -}
3d27b9b0a72d82f2123904b33e78c1f6
  $fShowDirection3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Down"#) -}
e4d53faf9d6c39b50bea299353442e90
  $fShowDirection4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Up"#) -}
8d4b988266ab87805c94d9bc03d5ebc3
  $fShowDirection_$cshow :: Logic.Direction -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Logic.Direction) ->
                 Logic.$fShowDirection_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8d4b988266ab87805c94d9bc03d5ebc3
  $fShowDirection_$cshowList :: [Logic.Direction] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Logic.Direction
                   Logic.$w$cshowsPrec) -}
8d4b988266ab87805c94d9bc03d5ebc3
  $fShowDirection_$cshowsPrec ::
    GHC.Types.Int -> Logic.Direction -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Logic.Direction)
                   (w2 :: GHC.Base.String) ->
                 Logic.$w$cshowsPrec w1 w2) -}
f8fdb6d9549dc40d8ac3963099c4e7cc
  $fShowGame :: GHC.Show.Show Logic.Game
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Logic.Game
                  Logic.$fShowGame_$cshowsPrec
                  Logic.$fShowGame_$cshow
                  Logic.$fShowGame_$cshowList -}
f8fdb6d9549dc40d8ac3963099c4e7cc
  $fShowGame1 :: Logic.Game -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Logic.Game) (w1 :: GHC.Base.String) ->
                 case w of ww { Logic.Game ww1 ww2 ww3 ->
                 Logic.$w$cshowsPrec1 0# ww1 ww2 ww3 w1 }) -}
f8fdb6d9549dc40d8ac3963099c4e7cc
  $fShowGame_$cshow :: Logic.Game -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Logic.Game) ->
                 Logic.$fShowGame_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f8fdb6d9549dc40d8ac3963099c4e7cc
  $fShowGame_$cshowList :: [Logic.Game] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Logic.Game Logic.$fShowGame1) -}
f8fdb6d9549dc40d8ac3963099c4e7cc
  $fShowGame_$cshowsPrec ::
    GHC.Types.Int -> Logic.Game -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U(U),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Logic.Game)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Logic.Game ww3 ww4 ww5 ->
                 Logic.$w$cshowsPrec1 ww1 ww3 ww4 ww5 w2 } }) -}
4fa20e1d7791eb45ef87dba3660bd24e
  $tc'Down :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18232846762688043528##
                   18281936744938520478##
                   Logic.$trModule
                   Logic.$tc'Down1) -}
a7ca4eda2ef27a06eaff3b0e64f25a24
  $tc'Down1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Down"#) -}
1232d652e6d3f69ec5e34aae23302426
  $tc'Game :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5771678855487124109##
                   4703363261136619661##
                   Logic.$trModule
                   Logic.$tc'Game1) -}
9980e24c06212492fb472c6103ca8a9f
  $tc'Game1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Game"#) -}
1ce3bad50caebf236d12bd80d447d70f
  $tc'Left :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11302623052860438285##
                   16093500655171599237##
                   Logic.$trModule
                   Logic.$tc'Left1) -}
21a6b5bb3e970aabd6b2f4eac0fd731c
  $tc'Left1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Left"#) -}
9d6a743a4abd3676629909ece48a821d
  $tc'Right :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8130921362139646981##
                   4795298733057935930##
                   Logic.$trModule
                   Logic.$tc'Right1) -}
b46f599ade895c49152bcd0c81e106b0
  $tc'Right1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Right"#) -}
a2bad89070d178d23ae30c5ee0579e76
  $tc'Up :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15534049488020788398##
                   7026184030414289888##
                   Logic.$trModule
                   Logic.$tc'Up1) -}
959fcddabfa2f453d9b6eb472890e0c3
  $tc'Up1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Up"#) -}
84a2dd36aae504ccb02fde1d4ddd3608
  $tcDirection :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6514310321929724876##
                   12796856936338236437##
                   Logic.$trModule
                   Logic.$tcDirection1) -}
b287ed25e0aac8bafa6eb6b0db5d242b
  $tcDirection1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Direction"#) -}
e25f8f20fff885d0035fa4fb00694e94
  $tcGame :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13481359486862523604##
                   16014765630118349941##
                   Logic.$trModule
                   Logic.$tcGame1) -}
c1e6bd3e6c9de00b20f48e100d0fd706
  $tcGame1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Game"#) -}
ca6564237fa0081dd05fb2c7d5fe07ca
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Logic.$trModule2 Logic.$trModule1) -}
35bdf61d5231cfb6344058c93d09cda1
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Logic"#) -}
06e77711d77f96dcf7572f74409c4ee9
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
11e8238f70af50b06592861caccc72d9
  $w$c== ::
    Logic.Grid
    -> GHC.Types.Int
    -> GHC.Types.Bool
    -> Logic.Grid
    -> GHC.Types.Int
    -> GHC.Types.Bool
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U><S,1*U><L,1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: Logic.Grid)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Bool)
                   (ww3 :: Logic.Grid)
                   (ww4 :: GHC.Types.Int)
                   (ww5 :: GHC.Types.Bool) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ [Logic.Tile]
                        Logic.$fEqGame_$s$fEq[]
                        ww
                        ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.$fEqBool_$c== ww2 ww5 } } } }) -}
8d4b988266ab87805c94d9bc03d5ebc3
  $w$cshowsPrec ::
    Logic.Direction -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Logic.Direction) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Logic.Up -> GHC.Base.++ @ GHC.Types.Char Logic.$fShowDirection4 w1
                   Logic.Down
                   -> GHC.Base.++ @ GHC.Types.Char Logic.$fShowDirection3 w1
                   Logic.Left
                   -> GHC.Base.++ @ GHC.Types.Char Logic.$fShowDirection2 w1
                   Logic.Right
                   -> GHC.Base.++ @ GHC.Types.Char Logic.$fShowDirection1 w1 }) -}
21f527c769792422661503d928f2e324
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Logic.Grid
    -> GHC.Types.Int
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <S,U><L,1*U><L,1*U(U)><L,1*U><L,U>,
     Inline: [0] -}
df25d59db7fbe45a67b370ef61c9b97c
  $wcheckRowMonotonicity :: [Logic.Tile] -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (w :: [Logic.Tile]) ->
                 case Logic.checkRowIncreasing w of wild {
                   GHC.Types.False
                   -> case Logic.checkRowDecreasing w of wild1 {
                        GHC.Types.False
                        -> case Logic.$wscoreRow w 0# of ww { DEFAULT ->
                           GHC.Prim.*# -1# ww }
                        GHC.Types.True -> Logic.$wscoreRow w 0# }
                   GHC.Types.True -> Logic.$wscoreRow w 0# }) -}
737f2dd061c406b2d849f1420be382de
  $wcountMergesInRow :: [Logic.Tile] -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
4178d278464efbc4f1a424eab987c5f6
  $wcountNothingInRow :: [Logic.Tile] -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
53e9f2a9955bd07d15ca3cbc96c39371
  $wdirectionStuckCheck ::
    GHC.Prim.Int# -> Logic.Grid -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: Logic.Grid) ->
                 case ww of ds {
                   DEFAULT -> Logic.directionStuckCheck2
                   1#
                   -> GHC.Classes.$fEq[]_$c==
                        @ [Logic.Tile]
                        Logic.$fEqGame_$s$fEq[]
                        w
                        (Data.OldList.transpose
                           @ Logic.Tile
                           (GHC.Base.map
                              @ [Logic.Tile]
                              @ [Logic.Tile]
                              Logic.leftRow
                              (Data.OldList.transpose @ Logic.Tile w)))
                   2#
                   -> GHC.Classes.$fEq[]_$c==
                        @ [Logic.Tile]
                        Logic.$fEqGame_$s$fEq[]
                        w
                        (Data.OldList.transpose
                           @ Logic.Tile
                           (GHC.Base.map
                              @ [Logic.Tile]
                              @ [Logic.Tile]
                              Logic.directionStuckCheck1
                              (Data.OldList.transpose @ Logic.Tile w)))
                   3#
                   -> GHC.Classes.$fEq[]_$c==
                        @ [Logic.Tile]
                        Logic.$fEqGame_$s$fEq[]
                        w
                        (GHC.Base.map
                           @ [Logic.Tile]
                           @ [Logic.Tile]
                           Logic.directionStuckCheck1
                           w)
                   4#
                   -> GHC.Classes.$fEq[]_$c==
                        @ [Logic.Tile]
                        Logic.$fEqGame_$s$fEq[]
                        w
                        (GHC.Base.map @ [Logic.Tile] @ [Logic.Tile] Logic.leftRow w) }) -}
22925244671758d673efa05324ccd8be
  $wdirectionStuckHeuristic ::
    GHC.Prim.Int# -> Logic.Grid -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: Logic.Grid) ->
                 case ww of ds {
                   DEFAULT
                   -> case Logic.directionStuckHeuristic1 ret_ty GHC.Prim.Int# of {}
                   1#
                   -> case GHC.Classes.$fEq[]_$c==
                             @ [Logic.Tile]
                             Logic.$fEqGame_$s$fEq[]
                             w
                             (Data.OldList.transpose
                                @ Logic.Tile
                                (GHC.Base.map
                                   @ [Logic.Tile]
                                   @ [Logic.Tile]
                                   Logic.leftRow
                                   (Data.OldList.transpose @ Logic.Tile w))) of wild {
                        GHC.Types.False -> 1# GHC.Types.True -> 0# }
                   2#
                   -> case GHC.Classes.$fEq[]_$c==
                             @ [Logic.Tile]
                             Logic.$fEqGame_$s$fEq[]
                             w
                             (Data.OldList.transpose
                                @ Logic.Tile
                                (GHC.Base.map
                                   @ [Logic.Tile]
                                   @ [Logic.Tile]
                                   Logic.directionStuckCheck1
                                   (Data.OldList.transpose @ Logic.Tile w))) of wild {
                        GHC.Types.False -> 1# GHC.Types.True -> 0# }
                   3#
                   -> case GHC.Classes.$fEq[]_$c==
                             @ [Logic.Tile]
                             Logic.$fEqGame_$s$fEq[]
                             w
                             (GHC.Base.map
                                @ [Logic.Tile]
                                @ [Logic.Tile]
                                Logic.directionStuckCheck1
                                w) of wild {
                        GHC.Types.False -> 1# GHC.Types.True -> 0# }
                   4#
                   -> case GHC.Classes.$fEq[]_$c==
                             @ [Logic.Tile]
                             Logic.$fEqGame_$s$fEq[]
                             w
                             (GHC.Base.map
                                @ [Logic.Tile]
                                @ [Logic.Tile]
                                Logic.leftRow
                                w) of wild {
                        GHC.Types.False -> 1# GHC.Types.True -> 0# } }) -}
903d26354eb6d3efa040ce8d564e6168
  $wfindBestMove :: Logic.Grid -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
6c17b56128392870d5063a78bed2a1ce
  $wfindBestMove2 ::
    Logic.Grid
    -> (# GHC.Types.Int, GHC.Types.Int, GHC.Types.Int, GHC.Types.Int,
          GHC.Types.Int #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
b16f01439147c027a6c0c30bb76bbca8
  $winsertRandomTile ::
    Logic.Grid -> (# [Logic.Tile], [[Logic.Tile]] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
6e923c16eabe7afe03662ba469784bf1
  $winsertRandomTileInRow ::
    [Logic.Tile] -> (# Logic.Tile, [Logic.Tile] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
a601bbf8002e2f7b9dc34e2e35ebd038
  $wlargeEdgeNumberHeuristic :: Logic.Grid -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
f07385e2bf2e56eed0bd9fe8b9487a1a
  $wmergesHeuristic :: Logic.Grid -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
7950b8eae9c1c2802767a0026e7985d8
  $wmonotonicityHeuristic :: Logic.Grid -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
9641d1710bf471567bfa02352cf76068
  $wmonteCarloPlayBoard ::
    Logic.Grid -> GHC.Types.Int -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 2, Strictness: <S,U><L,U(U)>, Inline: [0] -}
2bce29d1d89713404bc2b6b280e0e753
  $woneBestMove :: Logic.Grid -> (# [Logic.Tile], [[Logic.Tile]] #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (w :: Logic.Grid) ->
                 case Logic.$wfindBestMove w of ww {
                   DEFAULT
                   -> case Logic.oneBestMove1
                      ret_ty (# [Logic.Tile], [[Logic.Tile]] #)
                      of {}
                   1#
                   -> Logic.$winsertRandomTile
                        (Data.OldList.transpose
                           @ Logic.Tile
                           (GHC.Base.map
                              @ [Logic.Tile]
                              @ [Logic.Tile]
                              Logic.leftRow
                              (Data.OldList.transpose @ Logic.Tile w)))
                   2#
                   -> Logic.$winsertRandomTile
                        (Data.OldList.transpose
                           @ Logic.Tile
                           (GHC.Base.map
                              @ [Logic.Tile]
                              @ [Logic.Tile]
                              Logic.directionStuckCheck1
                              (Data.OldList.transpose @ Logic.Tile w)))
                   3#
                   -> Logic.$winsertRandomTile
                        (GHC.Base.map
                           @ [Logic.Tile]
                           @ [Logic.Tile]
                           Logic.directionStuckCheck1
                           w)
                   4# -> Logic.$winsertRandomTile (Logic.leftGrid w) }) -}
28967ae815fc8e393ed4427aba5e5195
  $wopenSquareHeuristic :: Logic.Grid -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
a7ba70fce30c84cf63a53d9ebd2c8645
  $wrandomlyPlayBoard :: Logic.Grid -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
fab76fea211f91879c8dc3f28e73f27e
  $wrandomlyPlayTilWin ::
    GHC.Prim.Int# -> Logic.Grid -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [0] -}
aff643c0d607763c4bff2780f57911b2
  $wrunRandomN :: Logic.Grid -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
e0dc0fa867d3e64f6a30feeb7f240e58
  $wscoreGrid :: Logic.Grid -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
4b7842fe96fc5aaf3a08a92da78beeb3
  $wscoreRow :: [Logic.Tile] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
4be22c53e08d1c9cb9ea1e3c8678227e
  $wxs :: GHC.Prim.Int# -> [GHC.Base.Maybe GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
8d4b988266ab87805c94d9bc03d5ebc3
  data Direction = Up | Down | Left | Right
f8fdb6d9549dc40d8ac3963099c4e7cc
  data Game
    = Game {_grid :: Logic.Grid,
            _score :: GHC.Types.Int,
            _done :: GHC.Types.Bool}
0042228100c73fede17ca0216502ec67
  type Grid = [[Logic.Tile]]
1a9892b7b8d21dece8bc89c897c777a2
  type Tile = GHC.Base.Maybe GHC.Types.Int
f094b15d85ebbe619187740131cacc4c
  _done :: Logic.Game -> GHC.Types.Bool
  RecSel Left Logic.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Logic.Game) ->
                 case ds of wild { Logic.Game ds1 ds2 ds3 -> ds3 }) -}
fe2b3cf42dd925e656f03729bfb1ee01
  _grid :: Logic.Game -> Logic.Grid
  RecSel Left Logic.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Logic.Game) ->
                 case ds of wild { Logic.Game ds1 ds2 ds3 -> ds1 }) -}
1b3a2e89fff8d270af45cc204639f487
  _score :: Logic.Game -> GHC.Types.Int
  RecSel Left Logic.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Logic.Game) ->
                 case ds of wild { Logic.Game ds1 ds2 ds3 -> ds2 }) -}
d964473dc4d99ec6d05d51a2bb1a826f
  checkFull :: Logic.Grid -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f4400e774b5606dfc578f905b87437b5
  checkRowDecreasing :: [Logic.Tile] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ebc1df722d269f61abfe68f28ec9003a
  checkRowFull :: [Logic.Tile] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
25a8d656cdc42a4eacc2369e053a165d
  checkRowIncreasing :: [Logic.Tile] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f8bbd167455c34a9ddb076d66d208a78
  checkRowMonotonicity :: [Logic.Tile] -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Logic.Tile]) ->
                 case Logic.$wcheckRowMonotonicity w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
a4bd4cccff6fd80e51ebf8cbb22ef407
  checkTileExists :: Logic.Tile -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (t :: Logic.Tile) ->
                 case t of wild {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just ipv -> GHC.Types.True }) -}
698b3b6e2eebc7c9c3c674431897a3d2
  colorGrid :: Logic.Grid -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Logic.colorGrid1
                  `cast`
                (<Logic.Grid>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
739937dbf19f2213175b482505cea22c
  colorGrid1 ::
    Logic.Grid
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
1e222ec8027f401467e5c811cdc33a83
  colorRow :: [Logic.Tile] -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Logic.colorRow1
                  `cast`
                (<[Logic.Tile]>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
e362db7d46967c187ab534e8c8c97dc8
  colorRow1 ::
    [Logic.Tile]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
bcdd5ca811590f58832c33ef575a0306
  countMergesInRow :: [Logic.Tile] -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Logic.Tile]) ->
                 case Logic.$wcountMergesInRow w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
0aa0bb67736f7317873841bd99cfe836
  countNothingInRow :: [Logic.Tile] -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Logic.Tile]) ->
                 case Logic.$wcountNothingInRow w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
2e11ef9ee962b28010bade3d39ceed34
  directionStuckCheck ::
    GHC.Types.Int -> Logic.Grid -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Logic.Grid) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Logic.$wdirectionStuckCheck ww1 w1 }) -}
7edcf371f177892ba3007abf7252ede6
  directionStuckCheck1 :: [Logic.Tile] -> [Logic.Tile]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ (x :: [Logic.Tile]) ->
                 GHC.List.reverse1
                   @ Logic.Tile
                   (Logic.leftRow (GHC.List.reverse @ Logic.Tile x))
                   (GHC.Types.[] @ Logic.Tile)) -}
e260ac92588fe605f0e637e0129490cb
  directionStuckCheck2 :: GHC.Types.Bool
  {- Strictness: x -}
4a5d9e6d1ad114d6604eb3fcb157d206
  directionStuckHeuristic ::
    GHC.Types.Int -> Logic.Grid -> GHC.Types.Int
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Logic.Grid) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Logic.$wdirectionStuckHeuristic ww1 w1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
e900a806d0f20a6ca6b630b54e05f16a
  directionStuckHeuristic1 :: GHC.Types.Int
  {- Strictness: x -}
9c1c68ce7bbdfcbbfe1b1c6aeb3d76a1
  done :: Lens.Micro.Type.Lens' Logic.Game GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ (f :: * -> *)
                   ($dFunctor :: GHC.Base.Functor f)
                   (f1 :: GHC.Types.Bool -> f GHC.Types.Bool)
                   (ds :: Logic.Game) ->
                 case ds of wild { Logic.Game x x1 x2 ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ GHC.Types.Bool
                   @ Logic.Game
                   (\ (y :: GHC.Types.Bool) -> Logic.Game x x1 y)
                   (f1 x2) }) -}
e510f6d7c945152898120296476f9b8a
  findBestMove :: Logic.Grid -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$wfindBestMove w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
b7fd4693aa77c2e33e984e5c54daaaf1
  findBestMove2 ::
    Logic.Grid
    -> (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int, GHC.Types.Int,
        GHC.Types.Int)
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$wfindBestMove2
                        w of ww { (#,,,,#) ww1 ww2 ww3 ww4 ww5 ->
                 (ww1, ww2, ww3, ww4, ww5) }) -}
d6fda91056afc97efd4307d3e5af7f5f
  grid :: Lens.Micro.Type.Lens' Logic.Game Logic.Grid
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ (f :: * -> *)
                   ($dFunctor :: GHC.Base.Functor f)
                   (f1 :: Logic.Grid -> f Logic.Grid)
                   (ds :: Logic.Game) ->
                 case ds of wild { Logic.Game x x1 x2 ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ Logic.Grid
                   @ Logic.Game
                   (\ (y :: Logic.Grid) -> Logic.Game y x1 x2)
                   (f1 x) }) -}
0ee2a09c993dd1a2be59fc05ab7ab589
  initGame :: GHC.Types.IO Logic.Game
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Logic.initGame1 `cast` (Sym (GHC.Types.N:IO[0] <Logic.Game>_R)) -}
a78d1ebb119fd6f52cfa80fc1108a176
  initGame1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Logic.Game #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# s, Logic.initGame2 #)) -}
64fc88862fc532a77e35a57c6ab648d9
  initGame10 :: [Logic.Tile]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ Logic.Tile
                   (GHC.Base.Nothing @ GHC.Types.Int)
                   Logic.initGame11) -}
4da3380e669090987b17f3b094098ef7
  initGame11 :: [GHC.Base.Maybe GHC.Types.Int]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe GHC.Types.Int)
                   (GHC.Base.Nothing @ GHC.Types.Int)
                   (GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Int))) -}
ba1a9a0c180d4f397cee87394d3bf84a
  initGame12 :: [Logic.Tile]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ Logic.Tile
                   Logic.initGame14
                   Logic.initGame13) -}
c83b553cb30c454ec2fbea2c2230db5d
  initGame13 :: [Logic.Tile]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ Logic.Tile
                   Logic.initGame14
                   Logic.initGame10) -}
c786341bd387e9e3f81f9f1c0359b7df
  initGame14 :: GHC.Base.Maybe GHC.Types.Int
  {- HasNoCafRefs,
     Unfolding: (GHC.Base.Just @ GHC.Types.Int Logic.initGame15) -}
30bf587d7b9e60c1f4ad30c7d8ba66df
  initGame15 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
221922c8285a7e09a71af8ef0497313e
  initGame2 :: Logic.Game
  {- HasNoCafRefs,
     Unfolding: (Logic.Game
                   Logic.initGame4
                   Logic.initGame3
                   GHC.Types.False) -}
d0f005f76eaf44cf639e93995b04ad20
  initGame3 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0#) -}
3842e399c2bad9f5d200a84a72869be1
  initGame4 :: [[Logic.Tile]]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ [Logic.Tile]
                   Logic.initGame12
                   Logic.initGame5) -}
e3298141d756248d792e880d7e55d86f
  initGame5 :: [[Logic.Tile]]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ [Logic.Tile]
                   Logic.initGame8
                   Logic.initGame6) -}
123e33a53cecb4d6e2be93210a0bb652
  initGame6 :: [[Logic.Tile]]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ [Logic.Tile]
                   Logic.initGame8
                   Logic.initGame7) -}
5de5f0d184e836c399ee97d828c582d0
  initGame7 :: [[Logic.Tile]]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ [Logic.Tile]
                   Logic.initGame8
                   (GHC.Types.[] @ [Logic.Tile])) -}
0a19c1b3be8b3908cb275241194ad9f9
  initGame8 :: [Logic.Tile]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ Logic.Tile
                   (GHC.Base.Nothing @ GHC.Types.Int)
                   Logic.initGame9) -}
55ef38da7d8be8a765bde3b9d42631db
  initGame9 :: [Logic.Tile]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ Logic.Tile
                   (GHC.Base.Nothing @ GHC.Types.Int)
                   Logic.initGame10) -}
6b6075d773b28b6f210964b096c886eb
  insertRandomTile :: Logic.Grid -> Logic.Grid
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$winsertRandomTile w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ [Logic.Tile] ww1 ww2 }) -}
ed5d7660b82c2266b0ca96a23a4dc1e2
  insertRandomTileInRow :: [Logic.Tile] -> [Logic.Tile]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Logic.Tile]) ->
                 case Logic.$winsertRandomTileInRow w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Logic.Tile ww1 ww2 }) -}
3e6f6804737d2f4bbad83b5e6ef29438
  largeEdgeNumberHeuristic :: Logic.Grid -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$wlargeEdgeNumberHeuristic w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
3734304773ada79feddf8dc8ba2281b4
  leftGrid :: Logic.Grid -> Logic.Grid
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (g :: Logic.Grid) ->
                 GHC.Base.build
                   @ [Logic.Tile]
                   (\ @ b1
                      (c :: [Logic.Tile] -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [Logic.Tile]
                      @ b1
                      (GHC.Base.mapFB @ [Logic.Tile] @ b1 @ [Logic.Tile] c Logic.leftRow)
                      n
                      g)) -}
559d15dcd0711a6b44e2daef95e5f2e0
  leftRow :: [Logic.Tile] -> [Logic.Tile]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (t :: [Logic.Tile]) ->
                 let {
                   x :: [Logic.Tile] = Logic.mergeRow t
                 } in
                 GHC.Base.++
                   @ (GHC.Base.Maybe GHC.Types.Int)
                   x
                   (case GHC.List.$wlenAcc
                           @ (GHC.Base.Maybe GHC.Types.Int)
                           x
                           0# of ww2 { DEFAULT ->
                    let {
                      y :: GHC.Prim.Int# = GHC.Prim.-# 4# ww2
                    } in
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<# 0# y) of wild {
                      GHC.Types.False -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Int)
                      GHC.Types.True -> Logic.$wxs y } })) -}
5859c3d52e51a3d069c36d0cb9517147
  makeRandomTile :: Logic.Tile
  {- Unfolding: (case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ GHC.Types.Int
                        Logic.makeRandomTile2 of ds { (#,#) ipv ipv1 ->
                 case ipv1 of wild { GHC.Types.I# x ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x 10#) of wild1 {
                   GHC.Types.False
                   -> GHC.Base.Just @ GHC.Types.Int Logic.makeRandomTile1
                   GHC.Types.True
                   -> GHC.Base.Just @ GHC.Types.Int Logic.initGame15 } } }) -}
87d8ca62b94297ad46b5c5790671f254
  makeRandomTile1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4#) -}
dadf17d8e477b14bae37c15d4db53c13
  makeRandomTile2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 1,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.Prim.noDuplicate# s of s' { DEFAULT ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, GHC.Types.Int)
                        @ GHC.Types.Int
                        r#
                        Logic.makeRandomTile3
                        s' of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { GHC.Types.I# ipv2 -> ds1 } } } }) -}
c3fe829fd4a2e1894e2c832c2284e6f3
  makeRandomTile3 ::
    System.Random.StdGen -> (System.Random.StdGen, GHC.Types.Int)
  {- Arity: 1,
     Unfolding: (\ (a1 :: System.Random.StdGen) ->
                 case System.Random.$wrandomIvalInteger
                        @ System.Random.StdGen
                        @ GHC.Types.Int
                        System.Random.$fRandomGenStdGen
                        GHC.Num.$fNumInt
                        Logic.makeRandomTile_w2
                        Logic.makeRandomTile_w1
                        a1 of ww2 { (#,#) ww3 ww4 ->
                 case ww4 of a'1 { System.Random.StdGen ipv ipv1 ->
                 (a'1, ww3) } }) -}
f098519c43186b1151bdd81781f48789
  makeRandomTile_w1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (10) -}
eb48e1af819ef5f462574dc86f9ffa39
  makeRandomTile_w2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
3025f437873ef6b6ba40f3dcb97ccb10
  mergeRow :: [Logic.Tile] -> [Logic.Tile]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a94cbbfde72011aa047e49a12c6e9447
  mergesHeuristic :: Logic.Grid -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$wmergesHeuristic w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
6e2ac24cb8d32b2a4917c62f934b7455
  monotonicityHeuristic :: Logic.Grid -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$wmonotonicityHeuristic w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
b1fe62a1fc9eafe2c83c8f7dba40b6cb
  monteCarloPlayBoard ::
    Logic.Grid -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 2, Strictness: <S,U><L,U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Logic.Grid) (w1 :: GHC.Types.Int) ->
                 case Logic.$wmonteCarloPlayBoard w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
255ac1fdcd437589fe85cb16fca8a8ab
  oneBestMove :: Logic.Grid -> Logic.Grid
  {- Arity: 1, Strictness: <S,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$woneBestMove w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ [Logic.Tile] ww1 ww2 }) -}
0d298bd7dc5c6e6e16858786fe3a95d2
  oneBestMove1 :: Logic.Grid
  {- Strictness: x -}
883e3341ff440edba61f84b339da5b2e
  oneMove :: Logic.Grid -> Logic.Grid
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (g :: Logic.Grid) ->
                 case Logic.oneMove6 of wild {
                   GHC.Types.False
                   -> case Logic.oneMove5 of wild1 {
                        GHC.Types.False
                        -> case Logic.oneMove4 of wild2 {
                             GHC.Types.False
                             -> case Logic.oneMove1 of wild3 {
                                  GHC.Types.False -> g
                                  GHC.Types.True
                                  -> case Logic.$winsertRandomTile
                                            (Logic.leftGrid g) of ww { (#,#) ww1 ww2 ->
                                     GHC.Types.: @ [Logic.Tile] ww1 ww2 } }
                             GHC.Types.True
                             -> case Logic.$winsertRandomTile
                                       (GHC.Base.map
                                          @ [Logic.Tile]
                                          @ [Logic.Tile]
                                          Logic.directionStuckCheck1
                                          g) of ww { (#,#) ww1 ww2 ->
                                GHC.Types.: @ [Logic.Tile] ww1 ww2 } }
                        GHC.Types.True
                        -> case Logic.$winsertRandomTile
                                  (Data.OldList.transpose
                                     @ Logic.Tile
                                     (GHC.Base.map
                                        @ [Logic.Tile]
                                        @ [Logic.Tile]
                                        Logic.directionStuckCheck1
                                        (Data.OldList.transpose
                                           @ Logic.Tile
                                           g))) of ww { (#,#) ww1 ww2 ->
                           GHC.Types.: @ [Logic.Tile] ww1 ww2 } }
                   GHC.Types.True
                   -> case Logic.$winsertRandomTile
                             (Data.OldList.transpose
                                @ Logic.Tile
                                (GHC.Base.map
                                   @ [Logic.Tile]
                                   @ [Logic.Tile]
                                   Logic.leftRow
                                   (Data.OldList.transpose
                                      @ Logic.Tile
                                      g))) of ww { (#,#) ww1 ww2 ->
                      GHC.Types.: @ [Logic.Tile] ww1 ww2 } }) -}
952d30034ca093bb1a55334354cd0ce7
  oneMove1 :: GHC.Types.Bool
  {- Unfolding: (case Logic.oneMove_randomDirection of wild { GHC.Types.I# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.False 4# -> GHC.Types.True } }) -}
7660ac20fa872fced9c8feb3b17271ca
  oneMove2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 1,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.Prim.noDuplicate# s of s' { DEFAULT ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, GHC.Types.Int)
                        @ GHC.Types.Int
                        r#
                        Logic.oneMove3
                        s' of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { GHC.Types.I# ipv2 -> ds1 } } } }) -}
258a81aaec53a7c91f1439728b67dfa1
  oneMove3 ::
    System.Random.StdGen -> (System.Random.StdGen, GHC.Types.Int)
  {- Arity: 1,
     Unfolding: (\ (a1 :: System.Random.StdGen) ->
                 case System.Random.$wrandomIvalInteger
                        @ System.Random.StdGen
                        @ GHC.Types.Int
                        System.Random.$fRandomGenStdGen
                        GHC.Num.$fNumInt
                        Logic.makeRandomTile_w2
                        Logic.oneMove_w1
                        a1 of ww2 { (#,#) ww3 ww4 ->
                 case ww4 of a'1 { System.Random.StdGen ipv ipv1 ->
                 (a'1, ww3) } }) -}
5854b4de3bab05341fec1f1223cf8c46
  oneMove4 :: GHC.Types.Bool
  {- Unfolding: (case Logic.oneMove_randomDirection of wild { GHC.Types.I# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.False 3# -> GHC.Types.True } }) -}
0291cd1e781c87381bd89e753bb49293
  oneMove5 :: GHC.Types.Bool
  {- Unfolding: (case Logic.oneMove_randomDirection of wild { GHC.Types.I# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.False 2# -> GHC.Types.True } }) -}
bd87ce0037b762736a3f354a4be7842a
  oneMove6 :: GHC.Types.Bool
  {- Unfolding: (case Logic.oneMove_randomDirection of wild { GHC.Types.I# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Types.True } }) -}
d601a9b78dea61e52396d25cb980508e
  oneMove_randomDirection :: GHC.Types.Int
  {- Unfolding: (case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ GHC.Types.Int
                        Logic.oneMove2 of ds { (#,#) ipv ipv1 ->
                 ipv1 }) -}
2da10947461cda1cd3fe0414c81b919b
  oneMove_w1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (4) -}
2305b330d991a8ab55ffa499224d5c68
  openSquareHeuristic :: Logic.Grid -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$wopenSquareHeuristic w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
71e75dfb3012d2685417b2b7b6d73c4f
  printTile :: Logic.Tile -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (t :: Logic.Tile) ->
                 case t of wild {
                   GHC.Base.Nothing -> Logic.printTile1
                   GHC.Base.Just n -> GHC.Show.$fShowInt_$cshow n }) -}
17e36ac47eecbe220e8ee61793bda53a
  printTile1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
092210df5277d37350dfc1ee144e000e
  randomlyPlayBoard :: Logic.Grid -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Logic.Grid) ->
                 case Logic.$wrandomlyPlayBoard w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
31d2a79df4e0fb312664b5dc5bd84e55
  randomlyPlayTilWin :: GHC.Types.Int -> Logic.Grid -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U(U)><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Logic.Grid) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Logic.$wrandomlyPlayTilWin ww1 w1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
0a374efe638d64db85fcd0050bc660fe
  removeNothings :: [Logic.Tile] -> [Logic.Tile]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
5e8e2c9c81b164e814e73a2e3ed24a77
  runRandomN :: Logic.Grid -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,U><S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Logic.Grid) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case Logic.$wrunRandomN w ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
b962a82045d7fd1c1fc4c37eba5644d7
  score :: Lens.Micro.Type.Lens' Logic.Game GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ (f :: * -> *)
                   ($dFunctor :: GHC.Base.Functor f)
                   (f1 :: GHC.Types.Int -> f GHC.Types.Int)
                   (ds :: Logic.Game) ->
                 case ds of wild { Logic.Game x x1 x2 ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ GHC.Types.Int
                   @ Logic.Game
                   (\ (y :: GHC.Types.Int) -> Logic.Game x y x2)
                   (f1 x1) }) -}
7b61f6e894d197317893065fabb1cab0
  scoreGrid :: Logic.Grid -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Logic.Grid) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case Logic.$wscoreGrid w ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
b130594941bec29406cdb52175f8d9d9
  scoreRow :: [Logic.Tile] -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [Logic.Tile]) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case Logic.$wscoreRow w ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
ba27a4dfa6e644b687c49a6bd2e0fe9b
  stuckCheck :: Logic.Grid -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
instance GHC.Classes.Eq [Logic.Direction] = Logic.$fEqDirection
instance GHC.Classes.Eq [Logic.Game] = Logic.$fEqGame
instance GHC.Show.Show [Logic.Direction] = Logic.$fShowDirection
instance GHC.Show.Show [Logic.Game] = Logic.$fShowGame
"SPEC/Logic $fEqMaybe @ Int" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                        GHC.Types.Int)
  GHC.Base.$fEqMaybe @ GHC.Types.Int $dEq
  = Logic.$fEqGame_$s$fEqMaybe
"SPEC/Logic $fEqMaybe_$c== @ Int" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                             GHC.Types.Int)
  GHC.Base.$fEqMaybe_$c== @ GHC.Types.Int $dEq
  = Logic.$fEqGame_$s$fEqMaybe_$c==
"SPEC/Logic $fEq[] @ (Maybe Int)" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                             (GHC.Base.Maybe GHC.Types.Int))
  GHC.Classes.$fEq[] @ (GHC.Base.Maybe GHC.Types.Int) $dEq
  = Logic.$fEqGame_$s$fEq[]
"SPEC/Logic $fEq[]_$c/= @ (Maybe Int)" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                  (GHC.Base.Maybe GHC.Types.Int))
  GHC.Classes.$fEq[]_$c/= @ (GHC.Base.Maybe GHC.Types.Int) $dEq
  = Logic.$fEqGame_$s$fEq[]_$c/=
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

